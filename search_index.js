var documenterSearchIndex = {"docs":
[{"location":"api/QExpressions/#QExpressions","page":"QExpressions","title":"QExpressions","text":"","category":"section"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"The QExpressions module provides the symbolic quantum expressions built on top of the operator and state spaces defined in statespace.   Expressions can represent single operator terms, sums of terms, indexed sums over subsystems, and full differential equations.","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"QAlgebra organizes expressions into:","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"Core struct types\nFunctions for constructing and simplifying expressions\nPretty-printing functions for strings and LaTeX output\nAlgebraic operations like commutators and symbolic sums","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"","category":"page"},{"location":"api/QExpressions/#Expression-Types","page":"QExpressions","title":"Expression Types","text":"","category":"section"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"We define the abstract types:","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QObj","page":"QExpressions","title":"QAlgebra.QExpressions.QObj","text":"QObj\n\nThe abstract type QObj is the base type for all quantum expressions in this module.\n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QAtom","page":"QExpressions","title":"QAlgebra.QExpressions.QAtom","text":"QAtom\n\nThe abstract type QAtom is a subtype of QObj and represents elementary operator definitions, such as QTerm and QAbstract. \n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QComposite","page":"QExpressions","title":"QAlgebra.QExpressions.QComposite","text":"QComposite\n\nThe abstract type QComposite is a subtype of QObj and represents composite expressions,  such as QSum and qAtomProduct which consist of QAtom, QAbstract or QComposite objects themselves. \n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"Where QObj describes the main class of all quantum objects, with the subtypes QAtom and QComposite representing the simplest and more complex quantum objects, respectively.","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"For the atomic operators we have ","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QTerm","page":"QExpressions","title":"QAlgebra.QExpressions.QTerm","text":"QTerm\n\nA QTerm represents a single term in a quantum expression. It contains:     - op_indices: A vector of indices representing the operators in the term, which are also defined in a StateSpace.\n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QAbstract","page":"QExpressions","title":"QAlgebra.QExpressions.QAbstract","text":"QAbstract(indices::Vector{Int})\n\nA purely‐symbolic abstract operator     - keyindex: The index of the abstractkey in the state space.     - subindex: The index of the suboperator in the statespace      - exponent: The exponent of the operator.     - dag: A boolean indicating whether the operator is daggered (default = false)     - operatortype: A reference to the operator of which it is a type      - indexmap: Keeps track of indexes, that are equal (for neq transformations) Is an instance of an OperatorType \n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"QTerm specifies a concrete operator, with components on one or multiple of the subsystems defined in a state space.\nQAbstract is an abstract type for all quantum operators, which can later be substituted for a concrete operator, but is now only known by its properties, such as its name, types (Hermitian, unitary, and the subspaces on which it acts etc.).","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"For composite operators we have","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.qAtomProduct","page":"QExpressions","title":"QAlgebra.QExpressions.qAtomProduct","text":"qAtomProduct\n\nA product of QAtom expressions, i.e. qTerms or QAbstract. It contains:     - statespace: The state space in which the product is defined.     - coeff_fun: The function of parameters for the Operator product     - expr: A vector of qAtoms (qTerms or QAbstract) that are multiplied together.\n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QCompositeProduct","page":"QExpressions","title":"QAlgebra.QExpressions.QCompositeProduct","text":"QCompositeProduct\n\nRepresents a product of qComposites. \n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QMultiComposite","page":"QExpressions","title":"QAlgebra.QExpressions.QMultiComposite","text":"QMultiComposite\n\nAbstract type for composite expressions that contain a Vector of qExpr objects.\n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.QSum","page":"QExpressions","title":"QAlgebra.QExpressions.QSum","text":"QSum\n\nA QSum represents the summation of a quantum Equation over indexes in a quantum expression. It contains:     - expr: The expression being summed over, which is a qExpr object.     - indexes: A vector of strings representing the summation indexes (e.g., \"i\").     - subsystem_index: The index of the subspace in which the indexes live.      - element_indexes: A vector of integers representing the position of the indexes in that subspace.     - neq: A boolean indicating whether different indexes in the sum can refer to the same element in the subspace.              For example, the indexes i,j,k can refer to different elements in a much larger bath of elements. \n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"Finally we have quantum expressions that are constructed as linear combinations of composite operators and differential equations in time ( d/dt \\langle \\text{Op} \\rangle ) which define the time derivative (of the expectation value) of a composite operator as a quantum expression","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.qExpr","page":"QExpressions","title":"QAlgebra.QExpressions.qExpr","text":"qExpr\n\nA qExpr represents a quantum equation, consisting of a Vector of quantum Expressions representing the additive terms of the equation. It also contains a reference to the state space in which the equation is defined.\n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/#QAlgebra.QExpressions.Diff_qEQ","page":"QExpressions","title":"QAlgebra.QExpressions.Diff_qEQ","text":"Diff_qEQ\n\nA Diff_qEQ represents a differential equation of the form:\n\nd/dt ⟨Op⟩ = RHS\n\nIt represents time evolution of operator expectation values, and wraps the symbolic structure of such an equation.\n\nFields\n\nleft_hand_side::QTerm: The LHS operator being differentiated.\nexpr::qExpr: The RHS symbolic expression.\nstatespace::StateSpace: The StateSpace in which the equation is defined.\nbraket::Bool: Whether to use braket notation ⟨⋯⟩ (default = true).\n\n\n\n\n\n","category":"type"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"","category":"page"},{"location":"api/QExpressions/#QObj-Construction","page":"QExpressions","title":"QObj Construction","text":"","category":"section"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"Quantum expressions can be constructed via ","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.term","page":"QExpressions","title":"QAlgebra.QExpressions.term","text":"term(operator_str::String, statespace::StateSpace)\nterm(coeff, operator_str::String, statespace::StateSpace)\nterm(coeff::Number, operator_str::String)\nterm(operator_str::String)\n\nGenerate a quantum term (QTerm) from the StateSpace q. The state description is provided as a string.\n\nTokens of the form var^exp (e.g. \"a^2\") set the exponent for a state variable.\nOther tokens are assumed to be keys that match one of the allowed subspace keys (i.e. elements in each SubSpace.keys) or  are abstract operator names in the StateSpace (with potential indexes, exponents and Daggers ').\nIf no coefficient is given, the default coefficient is 1.\nDaggers are given by ', and need to preceed a possible exponent\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.base_operators","page":"QExpressions","title":"QAlgebra.QExpressions.base_operators","text":"base_operators(ss:StateSpace; do_fun::Bool=false, formatted::Bool=false) -> Tuple{Dict{String,qExpr},Dict{String,qExpr},Dict{String,Union{Function, qExpr}}}\nbase_operators(statespace::StateSpace, name::String; do_fun::Bool=false, formatted::Bool=false, do_dict::Bool=true) -> Union{Dict{String,qExpr}, Dict{String, Function}, qExpr, Vector{qExpr}}\n\nReturns variables and/or operators in the state space ss. Specifc variables/operators can be selected by passing a string letter. If no letter is passed, the function returns a tuple of 3 dictionaries:\n\nThe first dictionary contains the variables in the state space, with their corresponding qExpr objects.\nThe second dictionary contains the operators in the state space, with their corresponding qExpr objects.\nThe third dictionary contains the abstract operators in the state space either as a callable function to specify the subtype or as a standard qExpr.\n\nIf you pass \"vars\", \"ops\" or \"abstract\", it will return a Dictionary with elements for each variable, operator or abstruct operator     - dofun specifies if abstract operators are returned as functions, that can be called with no arguments or with an integer to specify the subindex of the abstract operator.      - formatted specifies if the dictionary keys are formatted for example true would give: γᵢ, wheras false gives: gammai.      - do_dict specifies if for non basic (not vars, ops and abstract) elements, we return a dictionary of a Vector of the operators. Requires that the user knows the order of operators for the specific subspace\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.Sum","page":"QExpressions","title":"QAlgebra.QExpressions.Sum","text":"Sum(index::Union{String,Symbol,Vector{String},Vector{Symbol}}, expr::qExpr; neq::Bool=false) -> QSum\n\nConstructor of a QSum struct. Defines the indexes to sum over, the expressions for which to apply the sum and optionally whether the sum is only over non equal indexes. \n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.∑","page":"QExpressions","title":"QAlgebra.QExpressions.∑","text":"∑(index::Union{String,Symbol}, expr::qExpr; neq::Bool=false) -> QSum\n\nAlternative way to call the Sum constructor. Sum(index, expr; neq) = ∑(index, expr; neq).\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.d_dt","page":"QExpressions","title":"QAlgebra.QExpressions.d_dt","text":"d_dt(statespace::StateSpace, expr)\n\nEvaluate the time derivative of an expression expr in the context of the given state space ss.\n\nThis function expects that expr is an equation (i.e. an Expr with an equal sign as its head), of the form\n\nLHS = RHS\n\nThe function then returns a Diff_qEQ constructed from the left-hand side QTerm and the right-hand side qExpr.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QObj-Modification","page":"QExpressions","title":"QObj Modification","text":"","category":"section"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"General modifications of quantum objectscan be performed with","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.flatten","page":"QExpressions","title":"QAlgebra.QExpressions.flatten","text":"flatten(qeq::qExpr) -> qExpr\n\nFlattens nested Sums in quantum Equations (qExpr). Does not support QSums within qComposites within QSums!\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.neq","page":"QExpressions","title":"QAlgebra.QExpressions.neq","text":"neq(qeq::qExpr) -> qExpr\n\nTransform sums into neq sums, where all indexes are different from each other, and returns a flattened qExpr with neq sums.  Considers all cases of the sums, simplifying the cases in which indexes are the same, which then reduces the order of the sum (i.e. a sum{j} xi yj => sum{j} xi yj + imzi, where we used xiyi=im*zi).\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.simplify","page":"QExpressions","title":"QAlgebra.QExpressions.simplify","text":"simplify(q) -> simplified\n\nSimplifies qExpr-based symbolic quantum expressions by recursively reducing internal structures:\n\nqAtomProduct: Applies pairwise simplifications repeatedly and merges results into canonical qAtomProducts.\nQMultiComposite: Simplifies each expression element-wise.\nQComposite: Simplifies its internal expression and returns a new QComposite.\nqExpr: Flattens and simplifies terms, then combines like terms where possible.\nQSum: Simplifies its expression array and returns a new QSum.\nDiff_qEQ: Replaces its right-hand side with a simplified version.\n\nReturns either a single simplified object or a list of canonical components depending on input type.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.substitute","page":"QExpressions","title":"QAlgebra.QExpressions.substitute","text":"substitute(abstract_op::Union{qExpr, qAtomProduct, QAbstract}, replacement::Union{qExpr, qAtomProduct, QAtom}, target::Diff_qEQ, statespace::StateSpace) -> diff_q\nsubstitute(abstract_op::Union{qExpr, qAtomProduct, QAbstract}, replacement::Union{qExpr, qAtomProduct, QAtom}, target::qExpr) -> qExpr\n\nSubstitutes abstract_op with replacement in target. Keeps track of index changes due to for example neq. \n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.reorder!","page":"QExpressions","title":"QAlgebra.QExpressions.reorder!","text":"reorder!(q::Diff_qEQ) -> Diff_qEQ\n\nReorders the indexes of continuum-subspaces to the left, so that present indexes are i,j,k and not i,k,m. This allows simplify to further simplify expressions, by removing \n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QObj-Checks-and-Properties","page":"QExpressions","title":"QObj Checks and Properties","text":"","category":"section"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"The following scripts perform basic checks on the quantum expressions","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.is_numeric","page":"QExpressions","title":"QAlgebra.QExpressions.is_numeric","text":"is_numeric(t::QTerm, qspace::StateSpace) -> Bool\nis_numeric(t::QAbstract, qspace::StateSpace) -> Bool\nis_numeric(p::qAtomProduct) -> Bool\nis_numeric(s::QSum) -> Bool\nis_numeric(expr::qExpr) -> Bool\n\nReturns true if only the coefficient of the term(s) is non-zero.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.contains_abstract","page":"QExpressions","title":"QAlgebra.QExpressions.contains_abstract","text":"contains_abstract(q::QObj) -> Bool\n\nChecks if the quantum object contains an abstract operator among its leaves.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.which_continuum_acting","page":"QExpressions","title":"QAlgebra.QExpressions.which_continuum_acting","text":"which_continuum_acting(q::QObj)::Vector{Vector{Bool}}\n\nReturns a vector of vectors of booleans. Each inner vetor specifies which of its subsystem indexes are acted upon by the QObj.  This includes actions from FFunctions. Th function should only be applied after substituting all QAbstract terms.  Their present can be checked via contains_abstract(q).\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.are_indexes_defined","page":"QExpressions","title":"QAlgebra.QExpressions.are_indexes_defined","text":"are_indexes_defined(q::Diff_qEQ)::Bool\n\nChecks if all indexes n the differential equation are properly specified, either by the left-hand-side or  by QSums on the right-hand-side.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#Printing-and-Output-Formatting","page":"QExpressions","title":"Printing and Output Formatting","text":"","category":"section"},{"location":"api/QExpressions/#Base.string","page":"QExpressions","title":"Base.string","text":"string(eq::qExpr) -> String\nstring(eq::qAtomProduct) -> String\nstring(eq::Diff_qEQ) -> String\n\nReturns a string representation of the qExpr, qAtomProduct or Diff_qEQ object. The string is formatted in a human-readable way, but without LaTeX formatting.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.latex_string","page":"QExpressions","title":"QAlgebra.QExpressions.latex_string","text":"latex_string(eq::qExpr) -> String\nlatex_string(eq::qAtomProduct) -> String\nlatex_string(eq::Diff_qEQ) -> String\n\nReturns a LaTeX string representation of the qExpr, qAtomProduct or Diff_qEQ object. \n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"string returns a Unicode string representation of an expression (for console output).\nlatex_string returns a LaTeX-compatible string representation for notebook/HTML rendering.","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"Pretty-printing happens automatically when using display or println in environments like Jupyter or Pluto.","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"","category":"page"},{"location":"api/QExpressions/#4.-Algebraic-Operations","page":"QExpressions","title":"4. Algebraic Operations","text":"","category":"section"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"We overload the most common algebraic operations, such as +, *, -, and /, to work with QTerm, QAbstract, qExpr, QSum and Diff_qEQ types. We forthermore add the following functions:","category":"page"},{"location":"api/QExpressions/#QAlgebra.QExpressions.Dag","page":"QExpressions","title":"QAlgebra.QExpressions.Dag","text":"Dag(qspace::StateSpace, t::QTerm) -> QTerm\nDag(t::qExpr) -> qExpr\nDag(t::T) -> T where T <: QComposite\n\nReturns the Hermitian conjugate (dagger) of a QTerm, qExpr or QSum. Overloads the adjoint function, which can be called via t′.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/#QAlgebra.QExpressions.Commutator","page":"QExpressions","title":"QAlgebra.QExpressions.Commutator","text":"Commutator(Q1::qExpr, Q2::qExpr) -> qExpr\nCommutator(Q::qExpr, t::QSum) -> qExpr\nCommutator(t::QSum, Q::qExpr) -> qExpr\n\nComputes the commutator [Q1, Q2] = Q1 * Q2 - Q2 * Q1. Both qExpr's must share the same statespace.\n\n\n\n\n\n","category":"function"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"You can also construct commutators using vector notation:","category":"page"},{"location":"api/QExpressions/","page":"QExpressions","title":"QExpressions","text":"A = alpha * xi\nB = beta * yi\ncomm = A + [A, B]  # appends the commutator [A, B] to expression A","category":"page"},{"location":"api/other/#Other-Functions","page":"Other","title":"Other Functions","text":"","category":"section"},{"location":"api/other/","page":"Other","title":"Other","text":"The following are currently exposed functions and constants ","category":"page"},{"location":"api/other/#QAlgebra.StringUtils.symbol2formatted","page":"Other","title":"QAlgebra.StringUtils.symbol2formatted","text":"symbol2formatted(symbol::String) -> Tuple{String, String}\n\nReturns a tuple of (unicode_str, latex_str) for the given symbol, using variable substitution rules. Falls back to the raw symbol if no match is found.\n\n\n\n\n\n","category":"function"},{"location":"api/other/#QAlgebra.StringUtils.str2sub","page":"Other","title":"QAlgebra.StringUtils.str2sub","text":"str2sub(s::String) -> String\n\nConverts the input string s into a string with Unicode subscript characters. For characters not found in subscript_indexes, falls back to _c notation.\n\n\n\n\n\n","category":"function"},{"location":"api/other/#QAlgebra.StringUtils.str2sup","page":"Other","title":"QAlgebra.StringUtils.str2sup","text":"str2sup(s::String) -> String\n\nConverts the input string s into a string with Unicode superscript characters. For characters not found in superscript_indexes, falls back to ^c notation.\n\n\n\n\n\n","category":"function"},{"location":"api/other/#QAlgebra.StringUtils.superscript_indexes","page":"Other","title":"QAlgebra.StringUtils.superscript_indexes","text":"superscript_indexes::Dict{Char, String}\n\nContains the mapping from characters to their superscript representation for non-latex formatted outputs.\n\n\n\n\n\n","category":"constant"},{"location":"api/other/#QAlgebra.StringUtils.subscript_indexes","page":"Other","title":"QAlgebra.StringUtils.subscript_indexes","text":"subscript_indexes::Dict{Char, String}\n\nContains the mapping from characters to their subscript representation for non-latex formatted outputs.\n\n\n\n\n\n","category":"constant"},{"location":"api/FFunctions/#FFunctions","page":"FFunctions","title":"FFunctions","text":"","category":"section"},{"location":"api/FFunctions/","page":"FFunctions","title":"FFunctions","text":"The FFunctions module provides the structs and operations needed to express functions of classical variables. ","category":"page"},{"location":"api/FFunctions/#Types-/-Structs","page":"FFunctions","title":"Types / Structs","text":"","category":"section"},{"location":"api/FFunctions/#QAlgebra.FFunctions.FFunction","page":"FFunctions","title":"QAlgebra.FFunctions.FFunction","text":"FFunction\n\nAbstract supertype for symbolic functions representing atoms (FAtom), sums (FSum), and rationals (FRational).\n\n\n\n\n\n","category":"type"},{"location":"api/FFunctions/#QAlgebra.FFunctions.FAtom","page":"FFunctions","title":"QAlgebra.FFunctions.FAtom","text":"FAtom(coeff::Int, var_exponents::Vector{Int})\nFAtom(coeff::Rational, var_exponents::Vector{Int})\nFAtom(coeff::ComplexRational, var_exponents::Vector{Int})\n\nA single term with a complex‐rational coefficient and integer exponents for each variable.\n\nThe Int and Rational constructors wrap the coefficient into a ComplexRational.\nvar_exponents[j] is the exponent of variable j.\n\n\n\n\n\n","category":"type"},{"location":"api/FFunctions/#QAlgebra.FFunctions.FSum","page":"FFunctions","title":"QAlgebra.FFunctions.FSum","text":"FSum(terms::AbstractVector{<:FFunction})\nFSum(ts::FFunction...)\n\nConstructs a sum of FFunction terms.\n\nFlattens any nested FSum automatically.\nVariadic form FSum(a, b, c) is provided for convenience.\n\n\n\n\n\n","category":"type"},{"location":"api/FFunctions/#QAlgebra.FFunctions.FRational","page":"FFunctions","title":"QAlgebra.FFunctions.FRational","text":"FRational(numer::FSum, denom::FSum)\n\nRepresents a rational function with numerator numer and denominator denom, both sums of FFunction terms.\n\n\n\n\n\n","category":"type"},{"location":"api/FFunctions/#Interface-and-Utilities","page":"FFunctions","title":"Interface & Utilities","text":"","category":"section"},{"location":"api/FFunctions/#QAlgebra.FFunctions.isnumeric","page":"FFunctions","title":"QAlgebra.FFunctions.isnumeric","text":"isnumeric(a::FAtom)    -> Bool\nisnumeric(s::FSum)     -> Bool\nisnumeric(r::FRational) -> Bool\n\nReturns true if the expression contains no variables (i.e., all exponents are zero in atoms, and both numerator and denominator are numeric sums).\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#Base.iszero","page":"FFunctions","title":"Base.iszero","text":"iszero(a::FAtom)     -> Bool\niszero(s::FSum)      -> Bool\niszero(r::FRational) -> Bool\n\nReturns true if the expression is identically zero:\n\nAtom: zero coefficient.\nSum: all terms zero or empty.\nRational: zero numerator.\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.max_exponents","page":"FFunctions","title":"QAlgebra.FFunctions.max_exponents","text":"max_exponents(a::FAtom)    -> Vector{Int}\nmax_exponents(s::FSum)      -> Vector{Int}\nmax_exponents(r::FRational) -> Vector{Int}\n\nComputes the elementwise maximum of variable exponents:\n\nAtom: absolute value of its own exponents.\nSum: maximum across all terms.\nRational: maximum between numerator and denominator exponents.\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.build_xpows","page":"FFunctions","title":"QAlgebra.FFunctions.build_xpows","text":"build_xpows(x::Vector{<:Number}, max_exp::Vector{Int}) -> Vector{Vector}\n\nPrecomputes powers of each variable for fast evaluation:\n\nReturns xpows such that xpows[j][k+1] == x[j]^k for k = 0:max_exp[j].\nLengths of x and max_exp must agree.\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.evaluate","page":"FFunctions","title":"QAlgebra.FFunctions.evaluate","text":"evaluate(a::FAtom, xpows::Vector{Vector})       -> Number\nevaluate(s::FSum, xpows::Vector{Vector})        -> Number\nevaluate(r::FRational, xpows::Vector{Vector})   -> Number\n\nEvaluates the expression using precomputed powers xpows (as returned by build_xpows) for faster repeated evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.to_string","page":"FFunctions","title":"QAlgebra.FFunctions.to_string","text":"to_string(f::FFunction, vars::Vector{String};\n          do_latex::Bool = false,\n          braced::Bool = false,\n          optional_sign::Bool = true) -> String\n\nConverts an FFunction into a human‐readable string using variable names in vars.\n\nIf do_latex=true, uses LaTeX syntax (e.g. rac{} and superscripts).\nIf braced=true, wraps sums in parentheses.\nIf optional_sign=false, always prefixes a plus or minus sign.\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.stringer","page":"FFunctions","title":"QAlgebra.FFunctions.stringer","text":"stringer(f::FFunction, vars::Vector{String};\n         do_latex::Bool = false,\n         do_frac::Bool = true) -> (sign::Bool, body::String)\n\nInternal helper that converts an FFunction into a signed string using provided variable names. Used by to_string; returns a sign flag and a formatted string (in LaTeX or plain text).\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.sort_key","page":"FFunctions","title":"QAlgebra.FFunctions.sort_key","text":"sort_key(f::FFunction) -> Vector{<:Real}\n\nReturns a vector used to sort symbolic expressions in a canonical order:\n\nFAtom: variable exponents followed by a coefficient key.\nFSum: length and keys of terms.\nFRational: denominator keys first (priority), then numerator.\n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#QAlgebra.FFunctions.how_to_combine_Fs","page":"FFunctions","title":"QAlgebra.FFunctions.how_to_combine_Fs","text":"how_to_combine_Fs(ts::Vector{Union{FAtom, FSum}}) :: Tuple{Vector{Union{FAtom, FSum, Tuple{FAtom, Vector{Union{FAtom, FSum}}}}}, Vector{Vector{Int}}}\n\nGroups and combines FAtom and FSum objects in the input vector ts into composite structures that can be processed together.  Returns a tuple containing both the groups as (FFunction) elements of a Vector and the indexs corresponding to the elements in the groups.  The (FFunction) grouping is given either by a single FFunction element (either a single FAtom or a FSum) or by a tuple of an FAtom (F1) containing the shared factors, and a vector of FFunction elements (F2i), so that  together they represent a term of the form: F1 * (F21 + ... + F2_n). \n\n\n\n\n\n","category":"function"},{"location":"api/FFunctions/#Arithmetic-and-Operations","page":"FFunctions","title":"Arithmetic & Operations","text":"","category":"section"},{"location":"api/FFunctions/","page":"FFunctions","title":"FFunctions","text":"The module overloads the following arithmetic operations for objects of the structs defined above: +, -, *, /, ^, ==, ìnv, sort!, sort, copy, gcd, adjoint, conj You can also use FFunction.simplify to simplify your expressions, but this function is not explicitely exported.","category":"page"},{"location":"api/QSpace/#Operator-Spaces","page":"Operator Spaces","title":"Operator Spaces","text":"","category":"section"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"The statespace submodule defines the operator and variable structure of quantum systems. These spaces serve as the foundation for building symbolic quantum expressions in QAlgebra. It centers around the code struct StateSpace, which holds the entire system structure: subspaces, variables, time dependence, and indexing.","category":"page"},{"location":"api/QSpace/#Core-Types","page":"Operator Spaces","title":"Core Types","text":"","category":"section"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"The following additional types represent the building blocks of a composite quantum system:","category":"page"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"OperatorSet defines an algebra (e.g., Pauli, Ladder, PM) including how operators multiply, conjugate, and display.\nSubSpace represents one component of the full Hilbert space — each associated with an OperatorSet.\nParameter defines symbolic variables (e.g., alpha, beta(t), gamma_i) that appear in expressions.","category":"page"},{"location":"api/QSpace/#QAlgebra.QSpace.OperatorSet","page":"Operator Spaces","title":"QAlgebra.QSpace.OperatorSet","text":"OperatorSet(name::String, fermion::Bool, len::Int, neutral_element::Union{Int,Vector{Int}}, base_ops::Union{Vector{Int},Vector{Vector{Int}}}, ops::Vector{String}, op_product::Function, op_dag::Function, strs2ind::Function, op2str::Function, op2latex::Function)\n\nOperatorSets define the algebraic structure of a quantum system, defining ways to multiply and conjugate operators within the space, how to print them (both for plain and latex formatting), how to extract operators from strings. We provide a few standard operator sets, such as QubitPauli, QubitPM and Ladder.\n\n\n\n\n\n","category":"type"},{"location":"api/QSpace/#QAlgebra.QSpace.SubSpace","page":"Operator Spaces","title":"QAlgebra.QSpace.SubSpace","text":"SubSpace(key::String, keys::Vector{String}, statespace_main_ind::Int, statespace_inds::Vector{Int}, op_set::OperatorSet, continuum::Bool, fermion::Bool)\n\nSubSpace defines a subspace of a Hilbert space. It contains an operator set, aswell as additional information to reference and work with a subspace.  Fermionic subspaces support multiple copies of the same subspace, so as to support continuous generalisations of the subspace. \n\n\n\n\n\n","category":"type"},{"location":"api/QSpace/#QAlgebra.QSpace.Parameter","page":"Operator Spaces","title":"QAlgebra.QSpace.Parameter","text":"Parameter(var_name::String, var_of_t::Bool, var_of_continuum::Bool, var_continuum_index::Int=0; var_val::Union{Nothing,Number,Vector{Number},Function}=nothing, var_suffix::String=\"\")\n\nParameter is a struct that represents a variable in the state space, and information of how to access and print it.\n\n\n\n\n\n","category":"type"},{"location":"api/QSpace/#QAlgebra.QSpace.OperatorType","page":"Operator Spaces","title":"QAlgebra.QSpace.OperatorType","text":"OperatorType(name::String, hermitian::Bool=false, unitary::Bool=false, subspaces::Union{Nothing, Vector{Bool}}=nothing)\n\nDefine an operator Type, by declaring its name and properties such as hermitian and unitary. \n\n\n\n\n\n","category":"type"},{"location":"api/QSpace/#QAlgebra.QSpace.StateSpace","page":"Operator Spaces","title":"QAlgebra.QSpace.StateSpace","text":"StateSpace(args...; kwargs...)\n\nConstructs a combined Hilbert and Parameter space. The Hilbert space consists of different subspaces, themselves composed of different operator sets. The Parameter space defines the variables, that are needed to describe equations on the Hilbert space.     - args: A variable number of symbols or strings representing the state variables. Can refer to indexes of subsystems via for underscore notation, i.e., \"alpha_i\" or declare time dependence via for example \"alpha(t)\".     - kwargs: Each keyword is interpreted as a subspace label. The values are either Operator Sets or Tuples with an integer and an OperatorSet. The integer is the number of indexes generated for the subspace.     - operators: Specifies the types of abstract Operators from Strings such as \"A(U,H)\", which would result in an operator with name \"A\" and properties Hermitian (H) and Unitary (U).                     You can specify the subspaces on which the operator acts non trivially via the subspace keys (kwarg keys). Alternatively, you can specify the subspaces on which it doesn#t act non trivially via the negatved subspace keys (!kwarg keys).                     If no subspace is specified, it defaults to all subspaces.                     Example: \"A(U,H,i)\" constructs an abstract operator \"A\" that is both hermitian and unitary and acts non trivially on the subspace \"i\".                     Example: \"B(H,!i)\" constructs an abstract operator \"B\" that is hermitian and acts trivially on the subspace \"i\".                     Example: \"C(U)\" constructs an abstract operator \"C\" that is unitary and acts non-trivially on all subspaces.\n\n\n\n\n\n","category":"type"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"If a global state space is defined via the make_global parameter in the StateSpace constructor, it will be stored in the global variable ","category":"page"},{"location":"api/QSpace/#QAlgebra.QSpace.GLOBAL_STATE_SPACE","page":"Operator Spaces","title":"QAlgebra.QSpace.GLOBAL_STATE_SPACE","text":"GLOBAL_STATE_SPACE\n\nCan define a globally accessible StateSpace\n\n\n\n\n\n","category":"constant"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"","category":"page"},{"location":"api/QSpace/#Predefined-Operator-Sets","page":"Operator Spaces","title":"Predefined Operator Sets","text":"","category":"section"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"The package includes three standard operator sets for immediate use:","category":"page"},{"location":"api/QSpace/#QAlgebra.QSpace.Ladder","page":"Operator Spaces","title":"QAlgebra.QSpace.Ladder","text":"Ladder() -> OperatorSet\n\nCreates the OperatorSet for a bosonic mode using creation and annihilation operators (Ladder operators: a^dagger, a).\n\n\n\n\n\n","category":"function"},{"location":"api/QSpace/#QAlgebra.QSpace.QubitPM","page":"Operator Spaces","title":"QAlgebra.QSpace.QubitPM","text":"QubitPM() -> OperatorSet\n\nCreates the OperatorSet for a qubit using Raising and Lowering operators (sigma_+, sigma_-, sigma_z, sigma_I).\n\n\n\n\n\n","category":"function"},{"location":"api/QSpace/#QAlgebra.QSpace.QubitPauli","page":"Operator Spaces","title":"QAlgebra.QSpace.QubitPauli","text":"QubitPauli() -> OperatorSet\n\nCreates the OperatorSet for a qubit using Pauli operators (sigma_x, sigma_y, sigma_z, sigma_I).\n\n\n\n\n\n","category":"function"},{"location":"api/QSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"They each provide appropriate op_product, op_dag, and rendering functions, and can be passed as values to the StateSpace constructor.","category":"page"},{"location":"api/defaults/#Defaults-and-Precision-Settings","page":"Default Values","title":"Defaults and Precision Settings","text":"","category":"section"},{"location":"api/defaults/","page":"Default Values","title":"Default Values","text":"QAlgebra allows configuration of the number formatting used for coefficients, including float and exponential precision.   These defaults are persistent across sessions using Preferences.jl.","category":"page"},{"location":"api/defaults/#API","page":"Default Values","title":"API","text":"","category":"section"},{"location":"api/defaults/#QAlgebra.get_default","page":"Default Values","title":"QAlgebra.get_default","text":"get_default(name::Symbol)\n\nReturns the current default value for the coefficient preference with the given name. If no such preference has been set  it returns the default value from DEFAULT_COEFF_PREFS.\n\n\n\n\n\n","category":"function"},{"location":"api/defaults/#QAlgebra.set_flip_if_first_term_negative","page":"Default Values","title":"QAlgebra.set_flip_if_first_term_negative","text":"set_flip_if_first_term_negative(mode::Bool)\n\nSets a new default value for the first mode and saves it persistently. First mode specifies whether braced terms with a leading negative are flipped or only if all terms are negative.\n\n\n\n\n\n","category":"function"},{"location":"api/defaults/#QAlgebra.set_do_braced","page":"Default Values","title":"QAlgebra.set_do_braced","text":"set_do_braced(b::Bool)\n\nSets a new default value for :DO_BRACED. Toggles whether terms are grouped when printing them, into groups with common coefficients. \n\n\n\n\n\n","category":"function"},{"location":"#QAlgebra.jl","page":"Home","title":"QAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QAlgebra.jl provides symbolic tools for constructing and manipulating quantum operator expressions   on structured composite systems of qubits, spins, and bosonic modes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core abstraction is the StateSpace, which defines:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the symbolic variables (e.g. coupling constants),\nthe operator bases (e.g. Pauli, ladder, raising/lowering),\nand the indexed structure of composite systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Example:-Constructing-a-State-Space","page":"Home","title":"Example: Constructing a State Space","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using QAlgebra\nqspace = StateSpace(\"alpha\", \"beta(t)\", \"gamma_i\", \"delta_i\",\n                    operators=[\"A(!i)\", \"B(U,H,i)\"],\n                    h=QubitPM(), i=(3, QubitPauli()), b=Ladder())","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can access variables and operators from this space in several ways. By creating dictionaries of all variables, operators and abstract operators","category":"page"},{"location":"","page":"Home","title":"Home","text":"var_dict, op_dict, abstract_dict = base_operators(qspace)\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"individual variables ","category":"page"},{"location":"","page":"Home","title":"Home","text":"alpha = base_operators(qspace, \"alpha\")\nbeta  = base_operators(qspace, \"beta\")\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"individual subsystem bases (do_dict=true would return the entries as a dictionary):","category":"page"},{"location":"","page":"Home","title":"Home","text":"ph, mh, zh = base_operators(qspace, \"h\", do_dict=false)\nxi, yi, zi, pi, mi = base_operators(qspace, \"i\", do_dict=false)\nxj, yj, zj, pj, mj = base_operators(qspace, \"j\", do_dict=false)\nxk, yk, zk, pk, mk = base_operators(qspace, \"k\", do_dict=false)\nb, n = base_operators(qspace, \"b\", do_dict=false)\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"or specific abstract operators (with or without indexes or as a function accepting an index):","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = base_operators(qspace, \"A\")\nA1 = base_operators(qspace, \"A_1\")\nAs = base_operators(qspace, \"A\", do_fun=true)\nA, A1, As(2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Building,-Printing-and-Modifying-Expressions","page":"Home","title":"Building, Printing and Modifying Expressions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can build symbolic expressions using variables and operators:","category":"page"},{"location":"","page":"Home","title":"Home","text":"expr = 2 * (alpha + beta) * 1im * xi + alpha * Dag(b) * xi * yi","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can get the string and latex_string expressions via ","category":"page"},{"location":"","page":"Home","title":"Home","text":"string(expr)\nlatex_string(expr)\nnothing #hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We provide a number of useful operations, such as sums","category":"page"},{"location":"","page":"Home","title":"Home","text":"qsum = Sum(\"j\", alpha * yi * yj + Sum(\"k\", beta * alpha^2 * xi * xj * xk))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nested sums can be flattened","category":"page"},{"location":"","page":"Home","title":"Home","text":"flatten(qsum)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and you can enforce index distinction (i.e. j ne k):","category":"page"},{"location":"","page":"Home","title":"Home","text":"neq(qsum)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can define differential equations of operator expectation values","category":"page"},{"location":"","page":"Home","title":"Home","text":"diff_eq = d_dt(zi, alpha * expr + qsum)","category":"page"},{"location":"#Operator-Functions","page":"Home","title":"Operator Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We provide the following operator functions, with as of now limited support","category":"page"},{"location":"","page":"Home","title":"Home","text":"QCommutator(Sum(\"i\", alpha * ph * xi * yi) + zj, zh)","category":"page"},{"location":"","page":"Home","title":"Home","text":"exp(Sum(\"i\", alpha * ph * xi * yi) + zj) + zh","category":"page"},{"location":"","page":"Home","title":"Home","text":"log(Sum(\"i\", alpha * ph * xi * yi) + zj)","category":"page"},{"location":"","page":"Home","title":"Home","text":"power(Sum(\"i\", alpha * ph * xi * yi) + zj, 2) + zh","category":"page"},{"location":"","page":"Home","title":"Home","text":"root(Sum(\"i\", alpha * ph * xi * yi) + zj, 2) + zh","category":"page"},{"location":"#Simplify,-substitute-and-reorder-Expressions","page":"Home","title":"Simplify, substitute and reorder Expressions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can simplify expressions with ","category":"page"},{"location":"","page":"Home","title":"Home","text":"simplify(xi*yi+yi*xi)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Michael Schilling","category":"page"}]
}
