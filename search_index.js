var documenterSearchIndex = {"docs":
[{"location":"api/qSpace/#Operator-Spaces","page":"Operator Spaces","title":"Operator Spaces","text":"","category":"section"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"The qSpace submodule defines the operator and variable structure of quantum systems. These spaces serve as the foundation for building symbolic quantum expressions in qAlgebra. It centers around the code struct StateSpace, which holds the entire system structure: subspaces, variables, time dependence, and indexing.","category":"page"},{"location":"api/qSpace/#Core-Types","page":"Operator Spaces","title":"Core Types","text":"","category":"section"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"The following additional types represent the building blocks of a composite quantum system:","category":"page"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"OperatorSet defines an algebra (e.g., Pauli, Ladder, PM) including how operators multiply, conjugate, and display.\nSubSpace represents one component of the full Hilbert space — each associated with an OperatorSet.\nParameter defines symbolic variables (e.g., alpha, beta(t), gamma_i) that appear in expressions.","category":"page"},{"location":"api/qSpace/#qAlgebra.qSpace.OperatorSet","page":"Operator Spaces","title":"qAlgebra.qSpace.OperatorSet","text":"OperatorSet(name::String, fermion::Bool, len::Int, neutral_element::Union{Int,Vector{Int}}, base_ops::Union{Vector{Int},Vector{Vector{Int}}}, ops::Vector{String}, op_product::Function, op_dag::Function, strs2ind::Function, op2str::Function, op2latex::Function)\n\nOperatorSets define the algebraic structure of a quantum system, defining ways to multiply and conjugate operators within the space, how to print them (both for plain and latex formatting), how to extract operators from strings. We provide a few standard operator sets, such as QubitPauli, QubitPM and Ladder.\n\n\n\n\n\n","category":"type"},{"location":"api/qSpace/#qAlgebra.qSpace.SubSpace","page":"Operator Spaces","title":"qAlgebra.qSpace.SubSpace","text":"SubSpace(key::String, keys::Vector{String}, statespace_main_ind::Int, statespace_inds::Vector{Int}, op_set::OperatorSet, continuum::Bool, fermion::Bool)\n\nSubSpace defines a subspace of a Hilbert space. It contains an operator set, aswell as additional information to reference and work with a subspace.  Fermionic subspaces support multiple copies of the same subspace, so as to support continuous generalisations of the subspace. \n\n\n\n\n\n","category":"type"},{"location":"api/qSpace/#qAlgebra.qSpace.Parameter","page":"Operator Spaces","title":"qAlgebra.qSpace.Parameter","text":"Parameter(var_name::String, var_of_t::Bool, var_of_continuum::Bool, var_continuum_index::Int=0; var_val::Union{Nothing,Number,Vector{Number},Function}=nothing, var_suffix::String=\"\")\n\nParameter is a struct that represents a variable in the state space, and information of how to access and print it.\n\n\n\n\n\n","category":"type"},{"location":"api/qSpace/#qAlgebra.qSpace.StateSpace","page":"Operator Spaces","title":"qAlgebra.qSpace.StateSpace","text":"StateSpace(args...; kwargs...)\n\nConstructs a combined Hilbert and Parameter space. The Hilbert space consists of different subspaces, themselves composed of different operator sets. The Parameter space defines the variables, that are needed to describe equations on the Hilbert space.     - args: A variable number of symbols or strings representing the state variables. Can refer to indexes of subsystems via for underscore notation, i.e., \"alpha_i\" or declare time dependence via for example \"alpha(t)\".     - kwargs: Each keyword is interpreted as a subspace label. The values are either Operator Sets or Tuples with an integer and an OperatorSet. The integer is the number of indexes generated for the subspace.\n\n\n\n\n\n","category":"type"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"","category":"page"},{"location":"api/qSpace/#Predefined-Operator-Sets","page":"Operator Spaces","title":"Predefined Operator Sets","text":"","category":"section"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"The package includes three standard operator sets for immediate use:","category":"page"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"QubitPauli defines a qubit in the standard Pauli basis (sigma_x, sigma_y, sigma_z)\nQubitPM defines a qubit with aising/lowering basis (σ⁺, σ⁻, σᶻ)\nLadder defines a bosonic mode via ladder operators (b, b†)","category":"page"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"These are loaded from:","category":"page"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"include(\"OperatorSets/Qubit_Pauli.jl\")\ninclude(\"OperatorSets/Qubit_PM.jl\")\ninclude(\"OperatorSets/Ladder.jl\")","category":"page"},{"location":"api/qSpace/","page":"Operator Spaces","title":"Operator Spaces","text":"They each provide appropriate op_product, op_dag, and rendering functions, and can be passed as values to the StateSpace constructor.","category":"page"},{"location":"api/qExpressions/#qExpressions","page":"qExpressions","title":"qExpressions","text":"","category":"section"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"The qExpressions module provides the symbolic quantum expressions built on top of the operator and state spaces defined in qSpace.   Expressions can represent single operator terms, sums of terms, indexed sums over subsystems, and full differential equations.","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"qAlgebra organizes expressions into:","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"Core struct types\nFunctions for constructing and simplifying expressions\nPretty-printing functions for strings and LaTeX output\nAlgebraic operations like commutators and symbolic sums","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"","category":"page"},{"location":"api/qExpressions/#1.-Expression-Types","page":"qExpressions","title":"1. Expression Types","text":"","category":"section"},{"location":"api/qExpressions/#qAlgebra.qExpressions.qExpr","page":"qExpressions","title":"qAlgebra.qExpressions.qExpr","text":"qExpr\n\nThe abstract type qExpr is the base type for all quantum expressions in this module.\n\n\n\n\n\n","category":"type"},{"location":"api/qExpressions/#qAlgebra.qExpressions.qTerm","page":"qExpressions","title":"qAlgebra.qExpressions.qTerm","text":"qTerm\n\nA qTerm represents a single term in a quantum expression. It contains:     - coeff: The coefficient of the term, which can be a number (e.g., Int, Float64, Rational, etc.).     - var_exponents: A vector of integers representing the exponents of the state variables, defined in a StateSpace.     - op_indices: A vector of indices representing the operators in the term, which are also defined in a StateSpace.\n\n\n\n\n\n","category":"type"},{"location":"api/qExpressions/#qAlgebra.qExpressions.qEQ","page":"qExpressions","title":"qAlgebra.qExpressions.qEQ","text":"qEQ\n\nA qEQ represents a quantum equation, consisting of a Vector of quantum Expressions representing the additive terms of the equation. It also contains a reference to the state space in which the equation is defined.\n\n\n\n\n\n","category":"type"},{"location":"api/qExpressions/#qAlgebra.qExpressions.qSum","page":"qExpressions","title":"qAlgebra.qExpressions.qSum","text":"qSum\n\nA qSum represents the summation of a quantum Equation over indexes in a quantum expression. It contains:     - expr: The expression being summed over, which is a qEQ object.     - indexes: A vector of strings representing the summation indexes (e.g., \"i\").     - subsystem_index: The index of the subspace in which the indexes live.      - element_indexes: A vector of integers representing the position of the indexes in that subspace.     - neq: A boolean indicating whether different indexes in the sum can refer to the same element in the subspace.              For example, the indexes i,j,k can refer to different elements in a much larger bath of elements. \n\n\n\n\n\n","category":"type"},{"location":"api/qExpressions/#qAlgebra.qExpressions.diff_qEQ","page":"qExpressions","title":"qAlgebra.qExpressions.diff_qEQ","text":"diff_qEQ\n\nA diff_qEQ represents a differential equation of the form:\n\nd/dt ⟨Op⟩ = RHS\n\nIt represents time evolution of operator expectation values, and wraps the symbolic structure of such an equation.\n\nFields\n\nleft_hand_side::qTerm: The LHS operator being differentiated.\nright_hand_side::qEQ: The RHS symbolic expression.\nstatespace::StateSpace: The StateSpace in which the equation is defined.\nbraket::Bool: Whether to use braket notation ⟨⋯⟩ (default = true).\ndo_sigma::Bool: Whether to display Pauli operators as σₓ, etc. (default = true).\n\n\n\n\n\n","category":"type"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"qExpr is the abstract base type for all symbolic expressions.\nqTerm represents a single operator term with a coefficient.\nqEQ represents a sum of expressions.\nqSum represents a symbolic summation over indices.\ndiff_qEQ represents a differential equation ( d/dt \\langle \\text{Op} \\rangle ).","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"","category":"page"},{"location":"api/qExpressions/#2.-Basic-Construction-and-Simplification","page":"qExpressions","title":"2. Basic Construction and Simplification","text":"","category":"section"},{"location":"api/qExpressions/#qAlgebra.qExpressions.term","page":"qExpressions","title":"qAlgebra.qExpressions.term","text":"term(q::StateSpace, operator_str::String)\nterm(q::StateSpace, coeff, operator_str::String)\n\nGenerate a quantum term (qTerm) from the StateSpace q. The state description is provided as a string.\n\nTokens of the form var^exp (e.g. \"a^2\") set the exponent for a state variable.\nOther tokens are assumed to be keys that match one of the allowed subspace keys (i.e. elements in each SubSpace.keys).\nIf no coefficient is given, the default coefficient is 1.\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.simplify","page":"qExpressions","title":"qAlgebra.qExpressions.simplify","text":"simplify(q::qEQ) -> qEQ\nsimplify(q::qSum) -> qSum\nsimplify(q::diff_qEQ) -> diff_qEQ\n\nSimplify a qEQ, qSum or diff_qEQ by sorting terms and ading up terms that are equal (up to a coefficient). \n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.base_operators","page":"qExpressions","title":"qAlgebra.qExpressions.base_operators","text":"base_operators(letter::String, qspace::StateSpace) -> Union{Int,Vector{Int}}\n\nor      base_operators(ss:StateSpace) -> Tuple{Dict{String,qEQ},Dict{String,qEQ}}\n\nReturns variables and/or operators in the state space ss. Specifc variables/operators can be selected by passing a string letter. If no letter is passed, the function returns a tuple of two dictionaries:\n\nThe first dictionary contains the variables in the state space, with their corresponding qEQ objects.\nThe second dictionary contains the operators in the state space, with their corresponding qEQ objects.\n\nIf you pass \"vars\", it will return a tuple with elements for each variable\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.Sum","page":"qExpressions","title":"qAlgebra.qExpressions.Sum","text":"Sum(index::Union{String,Symbol,Vector{String},Vector{Symbol}}, expr::qEQ; neq::Bool=false) -> qSum\n\nConstructor of a qSum struct. Defines the indexes to sum over, the expressions for which to apply the sum and optionally whether the sum is only over non equal indexes. \n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.∑","page":"qExpressions","title":"qAlgebra.qExpressions.∑","text":"∑(index::Union{String,Symbol}, expr::qEQ; neq::Bool=false) -> qSum\n\nAlternative way to call the Sum constructor. Sum(index, expr; neq) = ∑(index, expr; neq).\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.flatten","page":"qExpressions","title":"qAlgebra.qExpressions.flatten","text":"flatten(qeq::qEQ) -> qEQ\n\nFlattens nested Sums in quantum Equations (qEQ).\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.neq","page":"qExpressions","title":"qAlgebra.qExpressions.neq","text":"neq(qeq::qEQ) -> qEQ\n\nTransform sums into neq sums, where all indexes are different from each other, and returns a flattened qEQ with neq sums.  Considers all cases of the sums, simplifying the cases in which indexes are the same, which then reduces the order of the sum (i.e. a sum{j} xi yj => sum{j} xi yj + imzi, where we used xiyi=im*zi).\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.d_dt","page":"qExpressions","title":"qAlgebra.qExpressions.d_dt","text":"d_dt(qspace::StateSpace, expr)\n\nEvaluate the time derivative of an expression expr in the context of the given state space ss.\n\nThis function expects that expr is an equation (i.e. an Expr with an equal sign as its head), of the form\n\nLHS = RHS\n\nThe function then returns a diff_qEQ constructed from the left-hand side qTerm and the right-hand side qEQ.\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.is_numeric","page":"qExpressions","title":"qAlgebra.qExpressions.is_numeric","text":"is_numeric(t::qTerm, qspace::StateSpace) -> Bool\nis_numeric(expr::qEQ) -> Bool\nis_numeric(s::qSum) -> Bool\n\nReturns true if only the coefficient of the term(s) is non-zero.\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"term constructs a single qTerm manually.\nsimplify combines like terms and removes near-zero terms.\nbase_operators extracts symbolic variables and operators from a StateSpace.\nSum and ∑ construct symbolic sums.\nflatten expands nested sums.\nneq enforces distinctness between summation indices.\nd_dt builds time derivatives (diff_qEQ).\nis_numeric checks if an expression simplifies to a pure number or neutral operator.","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"","category":"page"},{"location":"api/qExpressions/#3.-Printing-and-Output-Formatting","page":"qExpressions","title":"3. Printing and Output Formatting","text":"","category":"section"},{"location":"api/qExpressions/#Base.string","page":"qExpressions","title":"Base.string","text":"string(eq::qEQ) -> String\nstring(eq::qSum) -> String\nstring(eq::diff_qEQ) -> String\n\nReturns a string representation of the qEQ, qSum, or diff_qEQ object. The string is formatted in a human-readable way, but without LaTeX formatting.\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.latex_string","page":"qExpressions","title":"qAlgebra.qExpressions.latex_string","text":"latex_string(eq::qEQ) -> String\nlatex_string(eq::qSum) -> String\nlatex_string(eq::diff_qEQ) -> String\n\nReturns a LaTeX string representation of the qEQ, qSum, or diff_qEQ object. \n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"string returns a Unicode string representation of an expression (for console output).\nlatex_string returns a LaTeX-compatible string representation for notebook/HTML rendering.","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"Pretty-printing happens automatically when using display or println in environments like Jupyter or Pluto.","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"","category":"page"},{"location":"api/qExpressions/#4.-Algebraic-Operations","page":"qExpressions","title":"4. Algebraic Operations","text":"","category":"section"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"We overload the most common algebraic operations, such as +, *, -, and /, to work with qTerm, qEQ, qSum and diff_qEQ types. We forthermore add the following functions:","category":"page"},{"location":"api/qExpressions/#qAlgebra.qExpressions.Dag","page":"qExpressions","title":"qAlgebra.qExpressions.Dag","text":"Dag(t::qTerm, qspace::StateSpace) -> qTerm\nDag(t::qEQ) -> qEQ\nDag(t::qSum) -> qSum\n\nReturns the Hermitian conjugate (dagger) of a qTerm, qEQ or qSum. Overloads the adjoint function, which can be called via t′.\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/#qAlgebra.qExpressions.Commutator","page":"qExpressions","title":"qAlgebra.qExpressions.Commutator","text":"Commutator(Q1::qEQ, Q2::qEQ) -> qEQ\nCommutator(Q::qEQ, t::qSum) -> qEQ\nCommutator(t::qSum, Q::qEQ) -> qEQ\n\nComputes the commutator [Q1, Q2] = Q1 * Q2 - Q2 * Q1. Both qEQ's must share the same statespace.\n\n\n\n\n\n","category":"function"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"Dag computes the Hermitian conjugate (dagger) of an expression.\nCommutator computes the commutator ([A, B] = AB - BA).","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"You can also construct commutators using vector notation:","category":"page"},{"location":"api/qExpressions/","page":"qExpressions","title":"qExpressions","text":"A = alpha * xi\nB = beta * yi\ncomm = A + [A, B]  # appends the commutator [A, B] to expression A","category":"page"},{"location":"api/defaults/#Defaults-and-Precision-Settings","page":"Defaults","title":"Defaults and Precision Settings","text":"","category":"section"},{"location":"api/defaults/","page":"Defaults","title":"Defaults","text":"qAlgebra allows configuration of the number formatting used for coefficients, including float and exponential precision.   These defaults are persistent across sessions using Preferences.jl.","category":"page"},{"location":"api/defaults/#API","page":"Defaults","title":"API","text":"","category":"section"},{"location":"api/defaults/#qAlgebra.set_float_digits","page":"Defaults","title":"qAlgebra.set_float_digits","text":"set_float_digits(d::Int)\n\nSets a new default value for the digit precision of floating point coefficients and saves it persistently.\n\n\n\n\n\n","category":"function"},{"location":"api/defaults/#qAlgebra.set_exp_digits","page":"Defaults","title":"qAlgebra.set_exp_digits","text":"set_exp_digits(d::Int)\n\nSets a new default value for the digit precision of exponential coefficients and saves it persistently.\n\n\n\n\n\n","category":"function"},{"location":"#qAlgebra.jl","page":"Home","title":"qAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"qAlgebra.jl provides symbolic tools for building and manipulating quantum operator expressions   on structured composite systems of qubits, spins, or bosonic modes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core idea is to first define a StateSpace, which encodes the variables, subsystems, and operator bases.   From this space, symbolic expressions can be constructed and manipulated. Our expression types are","category":"page"},{"location":"","page":"Home","title":"Home","text":"qTerm: individual operator terms\nqEQ: additive symbolic expressions\nqSum: symbolic sums over indices\ndiff_qEQ: symbolic time evolution equations","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Composite operator algebra over structured subsystems\nIndexed sums with support for distinct (neq) indices\nExpression simplification, and expansion\nLaTeX output","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using qAlgebra\n\n# Generate the State Space consisting of a spin h using the raising and lowering basis (QubitPM), a spin bath in the Pauli Bases (QubitPauli) and a bosonic mode (Ladder).\nqs = StateSpace(\"alpha\", \"beta(t)\", \"gamma_i\", \"delta_i\", h=QubitPM(), i=(3, QubitPauli()), b=Ladder())\n\n# We can return a dictionary of the operators in the system\nvar_dict, op_dict = base_operators(qs)\n\n# Or individually for each subsystem (or subsystem index, i.e. i,j, and k) and variable\nxi, yi, zi = base_operators(\"i\", qs)\nxj, yj, zj = base_operators(\"j\", qs)\nxk, yk, zk = base_operators(\"k\", qs)\nph, mh, zh = base_operators(\"h\", qs)\nb = base_operators(\"b\", qs)\nI = base_operators(\"I\", qs)     # Identity operator\nalpha, beta, gamma_i, gamma_j, gamma_k, delta_i, delta_j, delta_k = base_operators(\"vars\", qs)\n\n# A simple expression can then be constructed from the operators \nexpr = 2 * alpha * im * xi + alpha * Dag(b) * xi * yi\n\n# It can be simplified via\nsimplified_expr = simplify(expr)\n\n# Sums can be constructed via \nqsum = Sum(\"j\", alpha*yi*yj+Sum(\"k\", beta*alpha^2*xi*xj*xk))\n\n# and the nested sum flattened via \nflat_qsum = flatten(qsum)\n\n# The sum still covers all combinations of indexes j,k\n# We can transform it into a neq sum, in which the indexes j and k are distinct. the following function then expands into all possible cases\nneq_sum = neq_sum(qsum) # this also flattens the sum\n\n# A differential equation of expectation values can be constructed via\ndiff_eq = d_dt(zi, alpha*expr+sum) # this simplifies, flattens and neq's the qEQ","category":"page"},{"location":"#Author","page":"Home","title":"Author","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Michael Schilling","category":"page"}]
}
